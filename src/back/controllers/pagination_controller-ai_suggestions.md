The `PaginationController` class you've implemented provides a structured way to handle pagination in a web context, managing the current page, next page, and previous page based on the total count of items and the given maximum page size. Below, I'll address the primary functionalities of the code, highlight potential issues, and suggest enhancements, including the incorporation of unit testing.

### Suggestions & Improvements:

1. **Correct Handling of `total_pages`**: The class currently references `self.total_pages` before it's defined. You should compute it in the `__init__` constructor and store that result so that it can be accessed later in the class.

2. **Exception Handling**: Instead of using an assertion in `get_total_pages`, you might want to raise a more informative exception which can be caught during runtime. Assertions can be disabled in optimized mode, leaving your code without protections in production.

3. **Pagination Logic in the `update` Method**: The method should handle invalid inputs gracefully. Generally, only valid `Direction` values should be accepted.

4. **Docstrings**: Adding more detailed docstrings to clarify the purpose of each method would enhance readability and maintainability.

5. **Unit Testing**: You can use Python's `unittest` module to create tests for this class. You should test:
   - Initialization under various conditions (e.g., zero items, one item, multiple items)
   - The behavior of the `update` method when navigating forward and backward
   - Validity of links generated by `prev_link` and `next_link`

Here's a modified version of your class with some of these improvements:

```python
from enum import Enum

class PaginationController:
    class Direction(Enum):
        PREV = -1
        NEXT = 1

    def __init__(self, total_count: int, max_page_size: int, filters_str: str) -> None:
        self.max_page_size: int = max_page_size
        self.total_pages: int = self.get_total_pages(total_count, max_page_size)
        self.last_page: int = self.total_pages - 1
        self.prev_page: int = None
        self.curr_page: int = 0
        self.next_page: int = None if self.total_pages == 1 else self.curr_page + 1
        self.filters_str: str = filters_str

    @property
    def prev_link(self) -> str | None:
        return self.get_pagination_link('assets', self.prev_page)

    @property
    def next_link(self) -> str | None:
        return self.get_pagination_link('assets', self.next_page)

    def get_pagination_link(self, resource: str, page: int | None) -> str | None:
        if page is None:
            return None
        return f'/{resource}/{str(page)}?{self.filters_str}'

    def get_total_pages(self, total_count: int, max_page_size: int) -> int:
        if total_count < 0:
            raise ValueError("Total count cannot be negative")
        return (total_count + max_page_size - 1) // max_page_size if total_count > 0 else 0

    def _update_forward(self) -> None:
        if self.curr_page < self.last_page:
            self.prev_page = self.curr_page
            self.curr_page += 1
            self.next_page = None if self.curr_page == self.last_page else self.curr_page + 1

    def _update_backward(self) -> None:
        if self.curr_page > 0:
            self.next_page = self.curr_page
            self.curr_page -= 1
            self.prev_page = None if self.curr_page == 0 else self.curr_page - 1

    def update(self, direction: Direction) -> None:
        if direction == self.Direction.NEXT:
            self._update_forward()
        elif direction == self.Direction.PREV:
            self._update_backward()

    def __repr__(self) -> str:
        return f"PaginationController(max_page_size={self.max_page_size}, total_pages={self.total_pages}, prev_page={self.prev_page}, curr_page={self.curr_page}, next_page={self.next_page})"
```

### Example of Unit Testing:

Here's a basic template for how you might set up unit tests using Python's `unittest` framework. Save this in a separate test file.

```python
import unittest

class TestPaginationController(unittest.TestCase):
    
    def test_initialization(self):
        pc = PaginationController(total_count=10, max_page_size=5, filters_str="sort=asc")
        self.assertEqual(pc.total_pages, 2)
        self.assertEqual(pc.prev_page, None)
        self.assertEqual(pc.curr_page, 0)
        self.assertEqual(pc.next_page, 1)

    def test_next_link(self):
        pc = PaginationController(total_count=10, max_page_size=5, filters_str="sort=asc")
        self.assertEqual(pc.next_link, "/assets/1?sort=asc")

    def test_update_forward(self):
        pc = PaginationController(total_count=10, max_page_size=5, filters_str="sort=asc")
        pc.update(PaginationController.Direction.NEXT)
        self.assertEqual(pc.curr_page, 1)
        
    def test_update_backward(self):
        pc = PaginationController(total_count=10, max_page_size=5, filters_str="sort=asc")
        pc.update(PaginationController.Direction.NEXT)  # Move to page 1
        pc.update(PaginationController.Direction.PREV)  # Move back to page 0
        self.assertEqual(pc.curr_page, 0)

    def test_get_pagination_link(self):
        pc = PaginationController(total_count=10, max_page_size=5, filters_str="sort=asc")
        self.assertIsNone(pc.get_pagination_link('assets', None))
        self.assertEqual(pc.get_pagination_link('assets', 0), "/assets/0?sort=asc")

if __name__ == '__main__':
    unittest.main()
```

With these modifications and tests, the `PaginationController` class would be more robust, easier to read, and the behavior of the methods can be verified through unit tests.
